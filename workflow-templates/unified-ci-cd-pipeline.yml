name: CI/CD Pipeline (Unified)

on:
  push:
    branches:
      - main
      - master
  pull_request:
    types: [closed]
    branches:
      - main
      - master
  release:
    types: [prereleased, released]
  workflow_dispatch:
    inputs:
      ref:
        description: "Commit SHA, Branch or Tag to deploy"
        required: false
        default: ""
      environment:
        description: "Environment to deploy to"
        required: true
        type: choice
        options:
          - sandbox
          - staging
          - production
      app_name:
        description: "Name of the app (defaults to repo name)"
        required: false
      namespace:
        description: "Kubernetes namespace (defaults to environment name)"
        required: false
      docker_build_dir:
        description: "Directory containing the Dockerfile and build context"
        required: false
        default: "."
      dockerfile_path:
        description: "Path to the Dockerfile relative to the docker_build_dir"
        required: false
        default: "Dockerfile"
      helm_chart:
        description: "Helm chart to use"
        required: false
        default: "oci://ghcr.io/forus-coop/forus-app"
      aws_region:
        description: "AWS region"
        required: false
        default: "us-west-2"

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      ref: ${{ steps.set-ref.outputs.ref }}
    steps:
      - name: Set environment based on event
        id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "release" && "${{ github.event.action }}" == "released" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "release" && "${{ github.event.action }}" == "prereleased" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "pull_request" && "${{ github.event.pull_request.merged }}" == "true" ]]; then
            echo "environment=sandbox" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/master" || "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=sandbox" >> $GITHUB_OUTPUT
          else
            echo "environment=skip" >> $GITHUB_OUTPUT
          fi

      - name: Set reference (SHA, branch, tag)
        id: set-ref
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.ref }}" != "" ]]; then
            echo "ref=${{ github.event.inputs.ref }}" >> $GITHUB_OUTPUT
          else
            echo "ref=${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

  build:
    needs: determine-environment
    if: needs.determine-environment.outputs.environment != 'skip'
    runs-on: ubuntu-latest
    outputs:
      image_uri: ${{ steps.build-image.outputs.image_uri }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ inputs.aws_region || 'us-west-2' }}
          # Note: You'll need to set these as secrets or use OIDC
          # aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          # aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          # Or use role-to-assume with OIDC
          # role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ github.event.inputs.app_name || github.event.repository.name }}
          IMAGE_TAG: ${{ needs.determine-environment.outputs.ref }}
          DOCKER_BUILD_DIR: ${{ github.event.inputs.docker_build_dir || '.' }}
          DOCKERFILE_PATH: ${{ github.event.inputs.dockerfile_path || 'Dockerfile' }}
        run: |
          docker build $DOCKER_BUILD_DIR -f $DOCKER_BUILD_DIR/$DOCKERFILE_PATH -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "image_uri=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "Image $IMAGE_TAG pushed to $ECR_REGISTRY/$ECR_REPOSITORY"

  deploy:
    needs: [determine-environment, build]
    if: needs.determine-environment.outputs.environment != 'skip'
    runs-on: ${{ needs.determine-environment.outputs.environment == 'production' && 'prod-runner' || needs.determine-environment.outputs.environment }}
    environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ inputs.aws_region || 'us-west-2' }}
          # Note: You'll need to set these as secrets or use OIDC
          # aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          # aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          # Or use role-to-assume with OIDC
          # role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}

      - name: Retrieve Kubeconfig
        env:
          KUBECONFIG_SECRET: ${{ secrets['ORG_KUBECTL_CONFIG_BASE64_' + needs.determine-environment.outputs.environment | upper] }}
        run: |
          mkdir -p ~/.kube
          echo "$KUBECONFIG_SECRET" | base64 --decode > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: 'latest'

      - name: Login to Helm registry
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | helm registry login ghcr.io/forus-coop --username ${{ github.repository_owner }} --password-stdin

      - name: Deploy with Helm
        env:
          APP_NAME: ${{ github.event.inputs.app_name || github.event.repository.name }}
          NAMESPACE: ${{ github.event.inputs.namespace || needs.determine-environment.outputs.environment }}
          HELM_CHART: ${{ github.event.inputs.helm_chart || 'oci://ghcr.io/forus-coop/forus-app' }}
          HELM_VALUES_FILE: ./helm/${{ needs.determine-environment.outputs.environment }}.yaml
          IMAGE_TAG: ${{ needs.determine-environment.outputs.ref }}
        run: |
          helm upgrade $APP_NAME $HELM_CHART \
            --install \
            --wait \
            --atomic \
            --namespace=$NAMESPACE \
            --set tag=$IMAGE_TAG \
            --values=$HELM_VALUES_FILE 